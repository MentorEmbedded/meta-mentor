#!/bin/sh

LANG=C
export LANG

OUTPUT="${MY_DIR}/output"
export OUTPUT

RESULT_FILE="${OUTPUT}/result.txt"
export RESULT_FILE

# print error and end the script
error_msg() {
    msg="$1"
    [ -z "${msg}" ] && msg="Unknown error"
    printf "ERROR: %s\n" "${msg}" >&2
    exit 1
}

# prints message, conventionally use it where script module doesn't work fine but script can be
# continued
warn_msg() {
    msg="$1"
    [ -z "${msg}" ] && msg="Unknown error"
    printf "WARNING: %s\n" "${msg}" >&2
}

# print general message
info_msg() {
    msg="$1"
    [ -z "${msg}" ] && msg="Unknown info"
    printf "INFO: %s\n" "${msg}" >&1
}

# Check if the script is run as root
check_root() {
    if [ "$(id -ru)" -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

# Check the exit status of last command executed and print the success or failure message on
# basis of exit status and end the script on failure
exit_on_fail() {
    exit_code="$?"
    [ "$#" -lt 2 ] && error_msg "Usage: exit_on_fail <success_phrase> <fail_phrase> [skip_list]"
    success_phrase="$1"
    fail_phrase="$2"
    skip_list="$3"

    if [ "${exit_code}" -ne 0 ]; then
        warn_msg "${fail_phrase}" | tee -a "${RESULT_FILE}"

        # skip_list is a list of tests separated by space. This might be
        # useful when exiting on prerequisite not met.
        if [ -n "${skip_list}" ]; then
            for i in ${skip_list}; do
                warn_msg "$i skipped" | tee -a "${RESULT_FILE}"
            done
        fi

        # Exit normally to continue to run the following steps defined in test
        # definition file.
        exit 0
    else
        info_msg "${success_phrase}" | tee -a "${RESULT_FILE}"
        return 0
    fi
}

# Print the success or failure message on basis of exit status of last command executed
check_return() {
    exit_code="$?"
    [ "$#" -ne 2 ] && error_msg "Usage: check_return <success_phrase> <fail_phrase>"
    success_phrase="$1"
    fail_phrase="$2"

    if [ "${exit_code}" -ne 0 ]; then
        warn_msg "${fail_phrase}" | tee -a "${RESULT_FILE}"
        return "${exit_code}"
    else
        info_msg "${success_phrase}" | tee -a "${RESULT_FILE}"
        return 0
    fi
}

# Print the success message
report_successful() {
    [ "$#" -ne 1 ] && error_msg "Usage: report_successful success_phrase"
    success_phrase="$1"
    info_msg "${success_phrase}" | tee -a "${RESULT_FILE}"
}

# Print the failure message
report_fail() {
    [ "$#" -ne 1 ] && error_msg "Usage: report_fail fail_phrase"
    fail_phrase="$1"
    warn_msg "${fail_phrase}" | tee -a "${RESULT_FILE}"
}

# Check dependency package if installed or not
check_deps() {
    pkgs="$1"
    [ -z "${pkgs}" ] && error_msg "Usage: check_deps pkgs"

    ! check_root && \
	    error_msg "About to check packages, please run this script as root."
    info_msg "Checking ${pkgs}"

    count=0
    for pkg in ${pkgs}; do
        opkg list-installed | grep -wq "${pkg} "
        check_return "${pkg} installed" "${pkg} not installed!"
	((count+=$?))
    done
    [ ${count} -eq 0 ]
    exit_on_fail "Dependencies are installed" "Dependency package/s not installed!"
}

# Return the exit code of the first command when using pipe.
pipe0_status() {
    [ "$#" -ne 2 ] && error_msg "Usage: pipe0_status cmd1 cmd2"
    cmd1="$1"
    cmd2="$2"

    exec 4>&1
    ret_val=$({ { eval "${cmd1}" 3>&-; echo "$?" 1>&3; } 4>&- \
                | eval "${cmd2}" 1>&4; } 3>&1)
    exec 4>&-

    return "${ret_val}"
}

# Create new output directory and rename the older one if any
create_out_dir() {
    [ -z "$1" ] && error_msg "Usage: create_out_dir output_dir"
    OUTPUT=$1
    [ -d "${OUTPUT}" ] &&
        mv "${OUTPUT}" "${OUTPUT}_$(date -r "${OUTPUT}" +%Y%m%d%H%M%S)"
    mkdir -p "${OUTPUT}"
    [ -d "${OUTPUT}" ] || error_msg "Could not create output directory ${OUTPUT}"
}

! check_root && error_msg "This script must be run as root"
create_out_dir "${OUTPUT}"
cd ${OUTPUT} || exit

info_msg "Output directory: ${OUTPUT}"
