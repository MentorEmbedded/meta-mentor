From 36c64467750823d42d5a4936afa6e96be6325bad Mon Sep 17 00:00:00 2001
From: Awais Belal <awais_belal@mentor.com>
Date: Tue, 29 Jan 2019 15:05:43 +0500
Subject: [PATCH 3/3] udev-extraconf/mount.sh: only mount devices on hotplug

fdisk from util-linux (2.31.1) and above allows the user to
manipulate an already mounted device. In order to achieve this
functionality it issues a BLKRRPART (block device re-read part)
ioctl and in response the kernel generates remove/change/add
events if the device is not mounted (manually unmounted etc)
which are caught and processed by udev. This causes our auto-mounter
to remount everything because it does not keep track and things
go out of control.
Differentiating between types of remove events such as the one
described above (generated by BLKRRPART) and one where the device
is physically plugged out is only possible using the DEVPATH variable
which is cleaned up only when the device is actually plugged-out.
This fixes the above anomaly by only mounting a device in add event
which is cleaned up properly (tmp cache deleted) in the remove event
or is not present in the tmp cache while making use of the DEVPATH
variable during the remove action.

Signed-off-by: Awais Belal <awais_belal@mentor.com>
---
 mount.sh | 33 ++++++++++++++++++++-------
 1 file changed, 26 insertions(+), 7 deletions(-)

Index: 1.1-r0/mount.sh
===================================================================
--- 1.1-r0.orig/mount.sh
+++ 1.1-r0/mount.sh
@@ -45,6 +45,13 @@ automount_systemd() {
         return
     fi
 
+	# Only go for auto-mounting when the device has been cleaned up in remove
+	# or has not been identified yet
+	if [ -e "/tmp/.automount-$name" ]; then
+		logger "mount.sh/automount" "[$MOUNT_BASE/$name] is already cached"
+		return
+	fi
+
     # Skip the partition which are already in /etc/fstab
     grep "^[[:space:]]*$DEVNAME" /etc/fstab && return
     for n in LABEL PARTLABEL UUID PARTUUID; do
@@ -104,6 +111,13 @@ automount() {
 		name="${LABEL}-${name}"
 	fi
 
+	# Only go for auto-mounting when the device has been cleaned up in remove
+	# or has not been identified yet
+	if [ -e "/tmp/.automount-$name" ]; then
+		logger "mount.sh/automount" "[$MOUNT_BASE/$name] is already cached"
+		return
+	fi
+
 	! test -d "$MOUNT_BASE/$name" && mkdir -p "$MOUNT_BASE/$name"
 	# Silent util-linux's version of mounting auto
 	if [ "x`readlink $MOUNT`" = "x/bin/mount.util-linux" ] ;
@@ -164,12 +178,18 @@ if [ "$ACTION" = "add" ] && [ -n "$DEVNA
 fi
 
 if [ "$ACTION" = "remove" ] || [ "$ACTION" = "change" ] && [ -x "$UMOUNT" ] && [ -n "$DEVNAME" ]; then
-    for mnt in `cat /proc/mounts | grep "$DEVNAME" | cut -f 2 -d " " `
-    do
-        $UMOUNT $mnt
-    done
-
-    # Remove empty directories from auto-mounter
-    name="`basename "$DEVNAME"`"
-    test -e "/tmp/.automount-$name" && rm_dir "$MOUNT_BASE/$name"
+	name="`basename "$DEVNAME"`"
+	tmpfile=`find /tmp | grep "\.automount-.*${name}$"`
+	if [ ! -e "/sys/$DEVPATH" -a -e "$tmpfile" ]; then
+                logger "mount.sh/remove" "cleaning up $DEVNAME, was mounted by the auto-mounter"
+                for mnt in `cat /proc/mounts | grep "$DEVNAME" | cut -f 2 -d " " `
+                do
+                        $UMOUNT $mnt
+                done
+                # Remove mount directory created by the auto-mounter
+		# and clean up our tmp cache file
+                mntdir=`cat "$tmpfile"`
+                rm_dir "$MOUNT_BASE/$mntdir"
+                rm "$tmpfile"
+        fi
 fi
