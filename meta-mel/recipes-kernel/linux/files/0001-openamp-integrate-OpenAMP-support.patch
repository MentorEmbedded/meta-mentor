From cfc0e081b42d0909c0b46928b70529aaa5479c83 Mon Sep 17 00:00:00 2001
From: Joe MacDonald <joe_macdonald@mentor.com>
Date: Thu, 11 Sep 2014 14:25:09 -0400
Subject: [PATCH] openamp: integrate OpenAMP support

Integrating the following updates from the team adding in MEMF support:

 - Modified GIC code to enable IPI usage in unicore kernel configuration

 - Addition of RPMSG platform driver to support rpmsg in remote Linux
   configuration

 - Configuration and make file changes to build the new drivers

 - Modifications to get correct CPU ID in unicore kernel configuration

Signed-off-by: Etsam Anjum <Etsam_Anjum@mentor.com>
Signed-off-by: Joe MacDonald <joe_macdonald@mentor.com>
---
 arch/arm/Kconfig                      |  11 +
 arch/arm/kernel/devtree.c             |   7 +-
 arch/arm/kernel/setup.c               |   7 +-
 drivers/irqchip/irq-gic.c             |  74 +++++-
 drivers/rpmsg/Kconfig                 |  17 ++
 drivers/rpmsg/Makefile                |   2 +
 drivers/rpmsg/rpmsg_user_dev_driver.c | 389 +++++++++++++++++++++++++++
 drivers/rpmsg/rpmsg_zynq_driver.c     | 476 ++++++++++++++++++++++++++++++++++
 drivers/rpmsg/rpmsg_zynq_internals.h  |  66 +++++
 9 files changed, 1045 insertions(+), 4 deletions(-)
 create mode 100644 drivers/rpmsg/rpmsg_user_dev_driver.c
 create mode 100644 drivers/rpmsg/rpmsg_zynq_driver.c
 create mode 100644 drivers/rpmsg/rpmsg_zynq_internals.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index a63a0c3..dc88694 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1912,6 +1912,17 @@ config XEN
 	help
 	  Say Y if you want to run Linux in a Virtual Machine on Xen on ARM.
 
+config OPENAMP
+	bool "Mentor Embedded Multicore Framework"
+	depends on RPMSG
+	help
+		Include support for the Mentor Embedded Multicore Framework (MEMF /
+		OpenAMP).  This allows Linux to be started by another operating system as
+		any other remoteproc driver would and can successfully operate as a UP
+		system even in SMP configurations.
+
+		Say Y if you intend to use OpenAMP, otherwise say N.
+
 endmenu
 
 menu "Boot options"
diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c
index f751714..d6e25a5 100644
--- a/arch/arm/kernel/devtree.c
+++ b/arch/arm/kernel/devtree.c
@@ -80,7 +80,12 @@ void __init arm_dt_init_cpu_maps(void)
 	 */
 	struct device_node *cpu, *cpus;
 	u32 i, j, cpuidx = 1;
-	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+	u32 mpidr =
+#if defined(CONFIG_OPENAMP)
+		read_cpuid_mpidr() & MPIDR_HWID_BITMASK;
+#else
+		is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+#endif
 
 	u32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID };
 	bool bootcpu_valid = false;
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 1e8b030..d8b615e 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -470,7 +470,12 @@ u32 __cpu_logical_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID };
 void __init smp_setup_processor_id(void)
 {
 	int i;
-	u32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+	u32 mpidr =
+#if defined(CONFIG_OPENAMP)
+		read_cpuid_mpidr() & MPIDR_HWID_BITMASK;
+#else
+		is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;
+#endif
 	u32 cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);
 
 	cpu_logical_map(0) = cpu;
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index 435ee9a..312d530 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -48,6 +48,57 @@
 
 #include "irqchip.h"
 
+#if defined(CONFIG_OPENAMP) && !defined(CONFIG_SMP)
+struct ipi {
+	void (*handler)(void);
+};
+
+static struct ipi ipi_types[8];
+
+void handle_IPI(int ipinr, struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	if (ipi_types[ipinr].handler) {
+		irq_enter();
+		(*ipi_types[ipinr].handler)();
+		irq_exit();
+	} else
+		pr_debug("CPU%u: Unknown IPI message %x\n", ipinr);
+
+	set_irq_regs(old_regs);
+}
+
+/*
+ * set_ipi_handler:
+ * Interface provided for a kernel module to specify an IPI handler function.
+ */
+int set_ipi_handler(int ipinr, void *handler, char *desc)
+{
+	if (ipi_types[ipinr].handler) {
+		pr_crit("IPI handler 0x%x already registered to %pf\n",
+					ipinr, ipi_types[ipinr].handler);
+		return -1;
+	}
+
+	ipi_types[ipinr].handler = handler;
+
+	return 0;
+}
+EXPORT_SYMBOL(set_ipi_handler);
+
+/*
+ * clear_ipi_handler:
+ * Interface provided for a kernel module to clear an IPI handler function.
+ */
+void clear_ipi_handler(int ipinr)
+{
+	ipi_types[ipinr].handler = NULL;
+}
+EXPORT_SYMBOL(clear_ipi_handler);
+
+#endif /* defined(CONFIG_OPENAMP) && !defined(CONFIG_SMP) */
+
 union gic_base {
 	void __iomem *common_base;
 	void __percpu __iomem **percpu_base;
@@ -312,7 +363,7 @@ static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs
 		}
 		if (irqnr < 16) {
 			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_OPENAMP)
 			handle_IPI(irqnr, regs);
 #endif
 			continue;
@@ -687,7 +738,26 @@ void gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 	raw_spin_unlock_irqrestore(&irq_controller_lock, flags);
 }
 EXPORT_SYMBOL(gic_raise_softirq);
-#endif
+#endif /* CONFIG_SMP */
+
+#ifdef CONFIG_OPENAMP
+void gic_raise_softirq_unicore(unsigned long cpu, unsigned int irq)
+{
+	unsigned long map = 0;
+
+	map |= 1 << cpu;
+
+	/*
+	 * Ensure that stores to Normal memory are visible to the
+	 * other CPUs before issuing the IPI.
+	 */
+	dsb();
+
+	/* this always happens on GIC0 */
+	writel_relaxed(map << 16 | irq, gic_data_dist_base(&gic_data[0]) + GIC_DIST_SOFTINT);
+}
+EXPORT_SYMBOL(gic_raise_softirq_unicore);
+#endif /* CONFIG_OPENAMP */
 
 #ifdef CONFIG_BL_SWITCHER
 /*
diff --git a/drivers/rpmsg/Kconfig b/drivers/rpmsg/Kconfig
index 73da8c2..fd1520c 100644
--- a/drivers/rpmsg/Kconfig
+++ b/drivers/rpmsg/Kconfig
@@ -13,6 +13,16 @@ config RPMSG_SERVER_SAMPLE
 	  This is just a sample server driver for the rpmsg bus.
 	  Say either Y or M. You know you want to.
 
+config RPMSG_ZYNQ
+	tristate "zynq rpmsg driver"
+	depends on RPMSG
+	---help---
+	  An rpmsg driver that exposes ZYNQ API to user space, in order to
+	  allow multimedia applications to offload ZYNQ processing to
+	  remote processors.
+
+	  If unsure, say N.
+
 config RPMSG_OMX
 	tristate "rpmsg OMX driver"
 	depends on RPMSG
@@ -30,6 +40,13 @@ config RPMSG_FREERTOS_STAT
 	  This is just a sample to get statistic from FreeRTOS.
 	  Say either Y or M. You know you want to.
 
+config RPMSG_USER
+	tristate "rpmsg user driver"
+	depends on RPMSG
+	---help---
+	User driver that exposes rpmsg services to application layer.
+
+
 source "drivers/rpmsg/host/Kconfig"
 
 endmenu
diff --git a/drivers/rpmsg/Makefile b/drivers/rpmsg/Makefile
index a9d9f67..2086b88 100644
--- a/drivers/rpmsg/Makefile
+++ b/drivers/rpmsg/Makefile
@@ -2,4 +2,6 @@ obj-$(CONFIG_RPMSG)	+= virtio_rpmsg_bus.o
 obj-$(CONFIG_RPMSG_SERVER_SAMPLE) += rpmsg_server_sample.o
 obj-$(CONFIG_RPMSG_FREERTOS_STAT) += rpmsg_freertos_statistic.o
 obj-$(CONFIG_RPMSG_OMX) += rpmsg_omx.o
+obj-$(CONFIG_RPMSG_ZYNQ) += rpmsg_zynq_driver.o
+obj-$(CONFIG_RPMSG_USER) += rpmsg_user_dev_driver.o
 obj-$(CONFIG_RPMSG)            += host/
diff --git a/drivers/rpmsg/rpmsg_user_dev_driver.c b/drivers/rpmsg/rpmsg_user_dev_driver.c
new file mode 100644
index 0000000..3cd362a
--- /dev/null
+++ b/drivers/rpmsg/rpmsg_user_dev_driver.c
@@ -0,0 +1,389 @@
+/*
+ * RPMSG User Device Kernel Driver
+ *
+ * Copyright (C) 2014 Mentor Graphics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/rpmsg.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/kfifo.h>
+#include <linux/uaccess.h>
+#include <linux/kthread.h>
+#include <linux/ioctl.h>
+#include <linux/errno.h>
+
+static struct class *rpmsg_class;
+static dev_t rpmsg_dev;
+
+struct _rpmsg_dev_params {
+	int rpmsg_major;
+	int rpmsg_minor;
+	struct device *rpmsg_dev;
+	struct cdev cdev;
+	struct rpmsg_channel *rpmsg_chnl;
+};
+
+struct _rpmsg_dev_instance {
+	struct rpmsg_endpoint *ept;
+	struct _rpmsg_dev_params *dev_params;
+	wait_queue_head_t usr_wait_q;
+	struct mutex sync_lock;
+};
+
+#define MAX_RPMSG_BUFF_SIZE		512
+#define RPMSG_KFIFO_SIZE		(MAX_RPMSG_BUFF_SIZE * 4)
+
+#define IOCTL_CMD_GET_KFIFO_SIZE	1
+#define IOCTL_CMD_GET_AVAIL_DATA_SIZE	2
+#define IOCTL_CMD_GET_FREE_BUFF_SIZE	3
+
+/* Shutdown message ID */
+#define SHUTDOWN_MSG			0xEF56A55A
+
+static struct kfifo rpmsg_kfifo;
+static int block_flag;
+static const char init_msg[] = "init_msg";
+
+static const char *const shutdown_argv[]
+		= { "/sbin/shutdown", "-h", "-P", "now", NULL };
+
+/* This callback gets invoked when we received data from the remote node */
+static void rpmsg_user_dev_drv_rx_cb(struct rpmsg_channel *rpdev,
+			void *data, int len, void *priv, u32 src)
+{
+	struct _rpmsg_dev_instance *rpmsg_dev_instance = priv;
+
+	/* Shutdown Linux if such a message is received. Only applicable
+	when Linux is a remoteproc remote. */
+	if ((*(int *) data) == SHUTDOWN_MSG) {
+		call_usermodehelper(shutdown_argv[0], shutdown_argv,
+					NULL, UMH_NO_WAIT);
+	} else {
+		/* Push data received into rpmsg kfifo */
+		mutex_lock_interruptible(&rpmsg_dev_instance->sync_lock);
+		kfifo_in(&rpmsg_kfifo, data, (unsigned int)len);
+		mutex_unlock(&rpmsg_dev_instance->sync_lock);
+
+		/* Wake up any blocking contexts waiting for data */
+		block_flag = 1;
+		wake_up_interruptible(&rpmsg_dev_instance->usr_wait_q);
+	}
+}
+
+
+static int rpmsg_dev_open(struct inode *inode, struct file *p_file)
+{
+	struct _rpmsg_dev_instance *rpmsg_dev_instance;
+	struct _rpmsg_dev_params *rpmsg_dev_params;
+	int retval;
+
+	/* Create and initialize rpmsg device instance */
+	rpmsg_dev_instance = kzalloc(sizeof(struct _rpmsg_dev_instance),
+					GFP_KERNEL);
+
+	if (!rpmsg_dev_instance) {
+		pr_err("\r\n cannot allocate memory for rpmsg device instance \r\n");
+		return -ENOMEM;
+	}
+
+	/* Initialize rpmsg instance with device params from inode */
+	rpmsg_dev_instance->dev_params = container_of(inode->i_cdev,
+					struct _rpmsg_dev_params, cdev);
+
+	rpmsg_dev_params = rpmsg_dev_instance->dev_params;
+
+	/* Allocate kfifo for rpmsg */
+	retval = kfifo_alloc(&rpmsg_kfifo, RPMSG_KFIFO_SIZE, GFP_KERNEL);
+	kfifo_reset(&rpmsg_kfifo);
+
+	if (retval) {
+		pr_err("\r\n error in kfifo_alloc for rpmsg \r\n");
+
+		return retval;
+	}
+
+	/* Initialize mutex */
+	mutex_init(&rpmsg_dev_instance->sync_lock);
+
+	/* Initialize wait queue head that provides blocking rx for userspace */
+	init_waitqueue_head(&rpmsg_dev_instance->usr_wait_q);
+
+	p_file->private_data = rpmsg_dev_instance;
+
+	/* Create endpoint for remote channel and register rx callabck */
+	rpmsg_dev_instance->ept = rpmsg_create_ept(rpmsg_dev_params->rpmsg_chnl,
+						rpmsg_user_dev_drv_rx_cb,
+						rpmsg_dev_instance,
+						RPMSG_ADDR_ANY);
+
+
+	if (!rpmsg_dev_instance->ept) {
+		pr_err(" Endpoint creation for failed!\r\n");
+		return -ENOMEM;
+	}
+
+	/* Send init message to remote to complete the connection stage.
+	The message carries the address of new endpoint so that the
+	further messages from remote are received in its call back */
+	retval = rpmsg_send_offchannel(rpmsg_dev_params->rpmsg_chnl,
+					rpmsg_dev_instance->ept->addr,
+					rpmsg_dev_params->rpmsg_chnl->dst,
+					init_msg, sizeof(init_msg));
+
+	if (retval) {
+		pr_err(" Init message send failed!\r\n");
+		return retval;
+	}
+
+	return 0;
+}
+
+static ssize_t rpmsg_dev_write(struct file *p_file,
+				const char __user *ubuff, size_t len,
+				loff_t *p_off)
+{
+	struct _rpmsg_dev_instance *rpmsg_dev_instance = p_file->private_data;
+	struct _rpmsg_dev_params *rpmsg_dev_params
+					= rpmsg_dev_instance->dev_params;
+	int err;
+	unsigned int size;
+	char *tmp_buff;
+
+	if (len < MAX_RPMSG_BUFF_SIZE)
+		size = len;
+	else
+		size = MAX_RPMSG_BUFF_SIZE;
+
+	tmp_buff = kzalloc(size, GFP_KERNEL);
+
+	if (copy_from_user(tmp_buff, ubuff, size)) {
+		pr_err("\r\n user to kernel buff copy error \r\n");
+		return -1;
+	}
+
+	err = rpmsg_send_offchannel(rpmsg_dev_params->rpmsg_chnl,
+					rpmsg_dev_instance->ept->addr,
+					rpmsg_dev_params->rpmsg_chnl->dst,
+					tmp_buff, size);
+
+	if (err) {
+		size = 0;
+		pr_err("\r\n rpmsg_send_off_channel error \r\n");
+	}
+
+	return size;
+}
+
+static ssize_t rpmsg_dev_read(struct file *p_file, char __user *ubuff,
+				size_t len, loff_t *p_off)
+{
+	struct _rpmsg_dev_instance *rpmsg_dev_instance = p_file->private_data;
+	int retval;
+	unsigned int data_available, data_used, bytes_copied;
+
+	/* Acquire lock to access rpmsg kfifo */
+	if (mutex_lock_interruptible(&rpmsg_dev_instance->sync_lock))
+		return -ERESTARTSYS;
+
+	data_available = kfifo_len(&rpmsg_kfifo);
+
+	if (data_available ==  0) {
+		/* Release lock */
+		mutex_unlock(&rpmsg_dev_instance->sync_lock);
+
+		/* if non-blocking read is requested return error */
+		if (p_file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		/* Block the calling context till data becomes available */
+		wait_event_interruptible(rpmsg_dev_instance->usr_wait_q,
+					block_flag != 0);
+	}
+
+	/* reset block flag */
+	block_flag = 0;
+
+	/* Provide requested data size to user space */
+	data_available = kfifo_len(&rpmsg_kfifo);
+	data_used = (data_available > len) ? len : data_available;
+	retval = kfifo_to_user(&rpmsg_kfifo, ubuff, data_used, &bytes_copied);
+
+	/* Release lock on rpmsg kfifo */
+	mutex_unlock(&rpmsg_dev_instance->sync_lock);
+
+	return retval ? retval : bytes_copied;
+}
+
+static long rpmsg_dev_ioctl(struct file *p_file, unsigned int cmd,
+				unsigned long arg)
+{
+	unsigned int tmp;
+
+	switch (cmd) {
+	case IOCTL_CMD_GET_KFIFO_SIZE:
+		tmp = kfifo_size(&rpmsg_kfifo);
+		if (copy_to_user((unsigned int *)arg, &tmp, sizeof(int)))
+			return -EACCES;
+		break;
+
+	case IOCTL_CMD_GET_AVAIL_DATA_SIZE:
+		tmp = kfifo_len(&rpmsg_kfifo);
+		pr_err("kfifo len ioctl = %d ", kfifo_len(&rpmsg_kfifo));
+		if (copy_to_user((unsigned int *)arg, &tmp, sizeof(int)))
+			return -EACCES;
+		break;
+	case IOCTL_CMD_GET_FREE_BUFF_SIZE:
+		tmp = kfifo_avail(&rpmsg_kfifo);
+		if (copy_to_user((unsigned int *)arg, &tmp, sizeof(int)))
+			return -EACCES;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rpmsg_dev_release(struct inode *inode, struct file *p_file)
+{
+	struct _rpmsg_dev_instance *rpmsg_dev_instance = p_file->private_data;
+
+	rpmsg_destroy_ept(rpmsg_dev_instance->ept);
+	kfree(rpmsg_dev_instance);
+
+	return 0;
+}
+
+static const struct file_operations rpmsg_dev_fops = {
+	.owner = THIS_MODULE,
+	.read = rpmsg_dev_read,
+	.write = rpmsg_dev_write,
+	.open = rpmsg_dev_open,
+	.unlocked_ioctl = rpmsg_dev_ioctl,
+	.release = rpmsg_dev_release,
+};
+
+static int rpmsg_user_dev_drv_probe(struct rpmsg_channel *rpdev)
+{
+	struct _rpmsg_dev_params *rpmsg_dev_params;
+
+	/* Allocate memory for the rpmsg device parameters data structure */
+	rpmsg_dev_params = kzalloc(sizeof(struct _rpmsg_dev_params),
+					GFP_KERNEL);
+
+	if (!rpmsg_dev_params) {
+		pr_err("\r\n cannot allocate memory for rpmsg device params \r\n");
+		return -ENOMEM;
+	}
+
+	/* Initialize rpmsg device parameters data structure */
+	rpmsg_dev_params->rpmsg_major = MAJOR(rpmsg_dev);
+	rpmsg_dev_params->rpmsg_minor = 0;
+	/* Create device */
+	rpmsg_dev_params->rpmsg_dev = device_create(rpmsg_class, &rpdev->dev,
+						rpmsg_dev, NULL, "rpmsg");
+	if (rpmsg_dev_params->rpmsg_dev == NULL) {
+		class_destroy(rpmsg_class);
+		unregister_chrdev_region(rpmsg_dev, 1);
+		return -1;
+	}
+	/* Initialize character device */
+	cdev_init(&rpmsg_dev_params->cdev, &rpmsg_dev_fops);
+	rpmsg_dev_params->cdev.owner = THIS_MODULE;
+	if (cdev_add(&rpmsg_dev_params->cdev, rpmsg_dev, 1) == -1) {
+		device_destroy(rpmsg_class, rpmsg_dev);
+		class_destroy(rpmsg_class);
+		unregister_chrdev_region(rpmsg_dev, 1);
+		return -1;
+	}
+	rpmsg_dev_params->rpmsg_chnl = rpdev;
+
+	dev_set_drvdata(&rpdev->dev, rpmsg_dev_params);
+
+	dev_info(&rpdev->dev, "new channel: 0x%x -> 0x%x!\n",
+			rpdev->src, rpdev->dst);
+
+	return 0;
+}
+
+static void rpmsg_user_dev_drv_remove(struct rpmsg_channel *rpdev)
+{
+	struct _rpmsg_dev_params *rpmsg_dev_params
+					= dev_get_drvdata(&rpdev->dev);
+
+	device_destroy(rpmsg_class, rpmsg_dev);
+	cdev_del(&rpmsg_dev_params->cdev);
+	kfree(rpmsg_dev_params);
+}
+
+static void rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+
+}
+
+static struct rpmsg_device_id rpmsg_user_dev_drv_id_table[] = {
+	{ .name	= "rpmsg-memf-demo-channel" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_user_dev_drv_id_table);
+
+static struct rpmsg_driver rpmsg_user_dev_drv = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= rpmsg_user_dev_drv_id_table,
+	.probe		= rpmsg_user_dev_drv_probe,
+	.callback	= rpmsg_cb,
+	.remove	= rpmsg_user_dev_drv_remove,
+};
+
+static int __init init(void)
+{
+	/* Allocate char device for this rpmsg driver */
+	if (alloc_chrdev_region(&rpmsg_dev, 0, 1, KBUILD_MODNAME) < 0) {
+		pr_err("\r\n Error allocating char device \r\n");
+		return -1;
+	}
+
+	/* Create device class for this device */
+	rpmsg_class = class_create(THIS_MODULE, KBUILD_MODNAME);
+
+	if (rpmsg_class == NULL) {
+		unregister_chrdev_region(rpmsg_dev, 1);
+		pr_err("\r\n Error allocating char device \r\n");
+		return -1;
+	}
+
+	/* Register this rpmsg driver with the rpmsg bus layer */
+	return register_rpmsg_driver(&rpmsg_user_dev_drv);
+}
+
+static void __exit fini(void)
+{
+	unregister_rpmsg_driver(&rpmsg_user_dev_drv);
+	class_destroy(rpmsg_class);
+	unregister_chrdev_region(rpmsg_dev, 1);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_DESCRIPTION("Sample driver to exposes rpmsg svcs to userspace via a char device");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/rpmsg/rpmsg_zynq_driver.c b/drivers/rpmsg/rpmsg_zynq_driver.c
new file mode 100644
index 0000000..36a3e4e
--- /dev/null
+++ b/drivers/rpmsg/rpmsg_zynq_driver.c
@@ -0,0 +1,476 @@
+/*
+ * Zynq Remote Processor Messaging Framework driver
+ *
+ * Copyright (C) 2014 Mentor Graphics Corporation
+ *
+ * Based on Zynq Remote Processor driver
+ *
+ * Copyright (C) 2012 Michal Simek <monstr@monstr.eu>
+ * Copyright (C) 2012 PetaLogix
+ *
+ * Based on origin OMAP Remote Processor driver
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_irq.h>
+#include <linux/virtio.h>
+#include <linux/virtio_ids.h>
+#include <linux/virtio_ring.h>
+#include <linux/virtio_config.h>
+#include <asm/outercache.h>
+#include <asm/cacheflush.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/idr.h>
+
+#include "rpmsg_zynq_internals.h"
+
+static DEFINE_IDA(rpmsg_zynq_dev_index);
+
+/* Globals. */
+struct work_struct zynq_rpmsg_work;
+
+struct platform_device *zynq_rpmsg_platform;
+struct zynq_rpmsg_instance *zynq_rpmsg_p;
+
+static void zynq_rpmsg_virtio_notify(struct virtqueue *vq)
+{
+	/* Notify the other core. */
+	if (vq == zynq_rpmsg_p->vrings[0].vq)
+		/* Raise soft IRQ on GIC. */
+		gic_raise_softirq_unicore(0, zynq_rpmsg_p->vring0);
+	else
+		gic_raise_softirq_unicore(0, zynq_rpmsg_p->vring1);
+}
+
+static void zynq_rpmsg_virtio_del_vqs(struct virtio_device *vdev)
+{
+	struct zynq_rpmsg_vring   *local_vring;
+	int i;
+
+	for (i = 0; i < ZYNQ_RPMSG_NUM_VRINGS; i++) {
+
+		local_vring = &(zynq_rpmsg_p->vrings[i]);
+
+		vring_del_virtqueue(local_vring->vq);
+
+		local_vring->vq =  NULL;
+
+		dma_free_coherent(&(zynq_rpmsg_platform->dev),
+					local_vring->len, local_vring->va,
+					local_vring->dma);
+	}
+}
+
+static int zynq_rpmsg_virtio_find_vqs(struct virtio_device *vdev,
+					unsigned nvqs, struct virtqueue *vqs[],
+					vq_callback_t *callbacks[],
+					const char *names[])
+{
+	int				i;
+	struct zynq_rpmsg_vring   *local_vring;
+	void				*vring_va;
+	int				 size;
+
+	/* Skip through the vrings. */
+	for (i = 0; i < nvqs; i++) {
+
+		local_vring = &(zynq_rpmsg_p->vrings[i]);
+
+		local_vring->len = zynq_rpmsg_p->num_descs;
+
+		size = vring_size(zynq_rpmsg_p->num_descs,
+					zynq_rpmsg_p->align);
+
+		/* Allocate non-cacheable memory for the vring. */
+		local_vring->va = dma_alloc_coherent
+					(&(zynq_rpmsg_platform->dev),
+					size, &(local_vring->dma), GFP_KERNEL);
+
+		vring_va = local_vring->va;
+
+		memset(vring_va, 0, size);
+
+		local_vring->vq = vring_new_virtqueue(i,
+						zynq_rpmsg_p->num_descs,
+						zynq_rpmsg_p->align, vdev,
+						false, vring_va,
+						zynq_rpmsg_virtio_notify,
+						callbacks[i], names[i]);
+
+		vqs[i] = local_vring->vq;
+	}
+
+	return 0;
+}
+
+static u8 zynq_rpmsg_virtio_get_status(struct virtio_device *vdev)
+{
+	return 0;
+}
+
+static void zynq_rpmsg_virtio_set_status(struct virtio_device *vdev, u8 status)
+{
+   /* */
+}
+
+static void zynq_rpmsg_virtio_reset(struct virtio_device *vdev)
+{
+	/* */
+}
+
+static u32 zynq_rpmsg_virtio_get_features(struct virtio_device *vdev)
+{
+	/* Return features. */
+	return zynq_rpmsg_p->dev_feature;
+}
+
+static void zynq_rpmsg_virtio_finalize_features(struct virtio_device *vdev)
+{
+	/* Set vring transport features. */
+	vring_transport_features(vdev);
+
+	zynq_rpmsg_p->gen_feature = vdev->features[0];
+}
+
+static void zynq_rpmsg_vdev_release(struct device *dev)
+{
+
+}
+
+static void mid_level_type_release(struct device *dev)
+{
+
+}
+
+static struct virtio_config_ops zynq_rpmsg_virtio_config_ops = {
+	.get_features	= zynq_rpmsg_virtio_get_features,
+	.finalize_features = zynq_rpmsg_virtio_finalize_features,
+	.find_vqs	= zynq_rpmsg_virtio_find_vqs,
+	.del_vqs	= zynq_rpmsg_virtio_del_vqs,
+	.reset		= zynq_rpmsg_virtio_reset,
+	.set_status	= zynq_rpmsg_virtio_set_status,
+	.get_status	= zynq_rpmsg_virtio_get_status,
+};
+
+static struct device_type mid_level_type = {
+	.name		= "rpmsg_mid",
+	.release	= mid_level_type_release,
+};
+
+static void handle_event(struct work_struct *work)
+{
+	struct virtqueue *vq;
+
+	flush_cache_all();
+
+	outer_flush_range(zynq_rpmsg_p->mem_start, zynq_rpmsg_p->mem_end);
+
+	vq = zynq_rpmsg_p->vrings[0].vq;
+
+	if (vring_interrupt(0, vq) == IRQ_NONE)
+		dev_dbg(&zynq_rpmsg_platform->dev, "no message found in vqid 0\n");
+}
+
+static void ipi_handler(void)
+{
+	schedule_work(&zynq_rpmsg_work);
+}
+
+static int zynq_rpmsg_deinitialize(struct platform_device *pdev)
+{
+	unregister_virtio_device(&(zynq_rpmsg_p->virtio_dev));
+
+	put_device(&(zynq_rpmsg_p->mid_dev));
+
+	dma_release_declared_memory(&pdev->dev);
+
+	clear_ipi_handler(zynq_rpmsg_p->vring0);
+
+	return 0;
+}
+
+static int zynq_rpmsg_initialize(struct platform_device *pdev)
+{
+	int ret = 0;
+	int index;
+	struct virtio_device *virtio_dev;
+
+	/* Register ipi handler. */
+	ret = set_ipi_handler(zynq_rpmsg_p->vring0, ipi_handler,
+				"Firmware kick");
+
+	if (ret) {
+		dev_err(&pdev->dev, "IPI handler already registered\n");
+		return -ENODEV;
+	}
+
+	/* Initialize work. */
+	INIT_WORK(&zynq_rpmsg_work, handle_event);
+
+	/* Memory allocations for vrings. */
+	ret = dma_declare_coherent_memory(&pdev->dev,
+					zynq_rpmsg_p->mem_start,
+					zynq_rpmsg_p->mem_start,
+					zynq_rpmsg_p->mem_end -
+					zynq_rpmsg_p->mem_start + 1,
+					DMA_MEMORY_IO);
+
+	if (!ret) {
+		dev_err(&pdev->dev, "dma_declare_coherent_memory failed\n");
+		return -ENODEV;
+	}
+
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+
+	if (ret) {
+		dev_err(&pdev->dev, "dma_set_coherent_mask: %d\n", ret);
+		return -ENODEV;
+	}
+
+	/* Initialize a mid-level device. Needed because of bad data structure
+	 * handling and assumptions within the virtio rpmsg bus. We are doing it
+	 * to just make sure that the virtio device has a parent device which
+	 * then itself has a parent in the form of the platform device. */
+	device_initialize(&(zynq_rpmsg_p->mid_dev));
+
+	zynq_rpmsg_p->mid_dev.parent = &(pdev->dev);
+	zynq_rpmsg_p->mid_dev.type = &mid_level_type;
+
+	index = ida_simple_get(&rpmsg_zynq_dev_index, 0, 0, GFP_KERNEL);
+
+	if (index < 0) {
+		put_device(&(zynq_rpmsg_p->mid_dev));
+		return -ENODEV;
+	}
+
+	dev_set_name(&(zynq_rpmsg_p->mid_dev), "rpmsg_mid%d", index);
+
+	device_add(&(zynq_rpmsg_p->mid_dev));
+
+	/* Setup the virtio device structure. */
+	virtio_dev = &(zynq_rpmsg_p->virtio_dev);
+
+	virtio_dev->id.device	= zynq_rpmsg_p->virtioid;
+	virtio_dev->config	  = &zynq_rpmsg_virtio_config_ops;
+	virtio_dev->dev.parent  = &(zynq_rpmsg_p->mid_dev);
+	virtio_dev->dev.release = zynq_rpmsg_vdev_release;
+
+	/* Register the virtio device. */
+	ret = register_virtio_device(virtio_dev);
+
+	dev_info(&(zynq_rpmsg_platform->dev), "virtio device registered \r\n");
+
+	return ret;
+}
+
+static int zynq_rpmsg_retrieve_dts_info(struct platform_device *pdev)
+{
+	const void *of_prop;
+	struct resource *res;
+
+	/* Retrieve memory information. */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "invalid address\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->mem_start = res->start;
+	zynq_rpmsg_p->mem_end = res->end;
+
+	/* Allocate free IPI number */
+	of_prop = of_get_property(pdev->dev.of_node, "vring0", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify vring0 node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->vring0 = be32_to_cpup(of_prop);
+
+
+	/* Read vring1 ipi number */
+	of_prop = of_get_property(pdev->dev.of_node, "vring1", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify vring1 node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->vring1 = be32_to_cpup(of_prop);
+
+	of_prop = of_get_property(pdev->dev.of_node, "num-descs", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify num descs node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->num_descs = be32_to_cpup(of_prop);
+
+	/* Read dev-feature  */
+	of_prop = of_get_property(pdev->dev.of_node, "dev-feature", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify dev features node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->dev_feature = be32_to_cpup(of_prop);
+
+	/* Read gen-feature */
+	of_prop = of_get_property(pdev->dev.of_node, "gen-feature", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify gen features node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->gen_feature = be32_to_cpup(of_prop);
+
+	/* Read number of vrings */
+	of_prop = of_get_property(pdev->dev.of_node, "num-vrings", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify num-vrings node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->num_vrings = be32_to_cpup(of_prop);
+
+	if (zynq_rpmsg_p->num_vrings > 2) {
+		dev_err(&pdev->dev, "We do not currently support more than 2 vrings.\n");
+		return -ENODEV;
+	}
+
+	/* Read vring alignment */
+	of_prop = of_get_property(pdev->dev.of_node, "alignment", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify alignment node property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->align = be32_to_cpup(of_prop);
+
+	/* Read virtio ID*/
+	of_prop = of_get_property(pdev->dev.of_node, "virtioid", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify virtio id property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->virtioid = be32_to_cpup(of_prop);
+
+	/* Read Ring Tx address. */
+	of_prop = of_get_property(pdev->dev.of_node, "ringtx", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify ring tx property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->ringtx = be32_to_cpup(of_prop);
+
+	/* Read Ring Rx address. */
+	of_prop = of_get_property(pdev->dev.of_node, "ringrx", NULL);
+	if (!of_prop) {
+		dev_err(&pdev->dev, "Please specify ringrx property\n");
+		return -ENODEV;
+	}
+
+	zynq_rpmsg_p->ringrx = be32_to_cpup(of_prop);
+
+	return 0;
+}
+
+static int zynq_rpmsg_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	zynq_rpmsg_platform = pdev;
+
+	/* Allocate memory for the Zynq RPMSG instance. */
+	zynq_rpmsg_p = kzalloc(sizeof(struct zynq_rpmsg_instance), GFP_KERNEL);
+
+	if (!zynq_rpmsg_p) {
+		dev_err(&pdev->dev, "Unable to alloc memory for zynq_rpmsg instance.\n");
+		return -ENOMEM;
+	}
+
+	/* Save the instance handle. */
+	platform_set_drvdata(pdev, zynq_rpmsg_p);
+
+	/* Retrieve the rquired information from DTS. */
+	ret = zynq_rpmsg_retrieve_dts_info(pdev);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failure in retrieving info from DTS.\n");
+		kzfree(zynq_rpmsg_p);
+		return -ENOMEM;
+	}
+
+	/* Perform all the initializations. */
+	ret = zynq_rpmsg_initialize(pdev);
+
+	return ret;
+}
+
+static int zynq_rpmsg_remove(struct platform_device *pdev)
+{
+	zynq_rpmsg_deinitialize(pdev);
+
+	kfree(zynq_rpmsg_p);
+
+	return 0;
+}
+
+
+/* Match table for OF platform binding */
+static struct of_device_id zynq_rpmsg_match[] = {
+	{ .compatible = "xlnx,zynq_rpmsg_driver", },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, zynq_rpmsg_match);
+
+static struct platform_driver zynq_rpmsg_driver = {
+	.probe = zynq_rpmsg_probe,
+	.remove = zynq_rpmsg_remove,
+	.driver = {
+		.name = "zynq_rpmsg_driver",
+		.owner = THIS_MODULE,
+		.of_match_table = zynq_rpmsg_match,
+	},
+};
+
+static int __init init(void)
+{
+	return platform_driver_register(&zynq_rpmsg_driver);
+}
+
+static void __exit fini(void)
+{
+	platform_driver_unregister(&zynq_rpmsg_driver);
+}
+
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Zynq RPMSG driver to use RPMSG framework without remoteproc");
diff --git a/drivers/rpmsg/rpmsg_zynq_internals.h b/drivers/rpmsg/rpmsg_zynq_internals.h
new file mode 100644
index 0000000..ddc096b
--- /dev/null
+++ b/drivers/rpmsg/rpmsg_zynq_internals.h
@@ -0,0 +1,66 @@
+/*
+ * Zynq Remote Processor Messaging Framework driver
+ *
+ * Copyright (C) 2014 Mentor Graphics Corporation
+ *
+ * Based on Zynq Remote Processor driver
+ *
+ * Copyright (C) 2012 Michal Simek <monstr@monstr.eu>
+ * Copyright (C) 2012 PetaLogix
+ *
+ * Based on origin OMAP Remote Processor driver
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ * Copyright (C) 2011 Google, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#define ZYNQ_RPMSG_NUM_VRINGS		2
+struct zynq_rpmsg_vring {
+
+	void	   *va;
+	dma_addr_t dma;
+	int		len;
+	u32		da;
+	u32		align;
+	struct virtqueue *vq;
+};
+
+struct zynq_rpmsg_instance {
+
+	u32	 vring0;
+	u32	 vring1;
+	u32	 mem_start;
+	u32	 mem_end;
+	u32	 num_descs;
+	u32	 dev_feature;
+	u32	 gen_feature;
+	u32	 num_vrings;
+	u32	 align;
+	u32	 virtioid;
+	u32	 ringtx;
+	u32	 ringrx;
+
+	struct virtio_device virtio_dev;
+
+	struct zynq_rpmsg_vring vrings[ZYNQ_RPMSG_NUM_VRINGS];
+
+	struct device mid_dev;
+};
+
+#ifndef CONFIG_SMP
+extern int set_ipi_handler(int ipinr, void *handler, char *desc);
+
+extern void clear_ipi_handler(int ipinr);
+
+extern void gic_raise_softirq_unicore(unsigned long cpu, unsigned int irq);
+#endif
-- 
1.9.1

