#!/bin/bash

###############################################################################
# Name: Capture/Debug Information Tool
# Description:
#  Script to capture debug info from a MEL user's host
#
#
# Copyright 2007-2013 Mentor Graphics Corporation
#
# This file is licensed under the terms of the GNU General Public License
# version 2.  This program  is licensed "as is" without any warranty of any
# kind, whether express or implied.


# Variables
unset BUILDDIR   # Path of the MEL build directory
unset BUILDERR   # Path and filename of the MEL build error log file
unset MELDIR     # Root path of the MEL installation directory

WORKDIR=${PWD}
HOMEDIR=${HOME}
HOSTINFOFILE="hostinfo.txt"    # File containing info captured from user's host
OUTPUTDIRNAME="capdebuginfo"   # Directory containing all info captured by script
SCRIPT_NAME="$(basename ${BASH_SOURCE})"
MGLS_LICENSE="MGLS_LICENSE_FILE"
LM_LICENSE="LM_LICENSE_FILE"


usage () {
   cat >&2 <<END

Description:
   Capture debug info from a MEL user's host such as host environment and project log files.
   
Modes of operation:
   With input arguments: ${SCRIPT_NAME} -e <BUILDERR> -i <MELDIR>
     
   Without input arguments: ${SCRIPT_NAME}
   
Usage: ${SCRIPT_NAME} -e <BUILDERR> -i <MELDIR>
   or  ${SCRIPT_NAME}
   
   -e <BUILDERR>   Specify complete path and filename of the MEL build error log file
   -i <MELDIR>     Specify the root path of the MEL installation directory 
   -h              Show this usage information

END
}


abspath () {
    readlink -e "${1}"
}


# Process input arguments to the script
#   Input:  $@
process_cmdline_args () {
   while getopts ":e:i:h" opt; do
      case "${opt}" in
         e)
            # Handle getops with invalid input
            if [[ ${OPTARG} == -* ]] ; then
               echo "Invalid input for option -${opt}"
               shift $((OPTIND-1))
               break
            else
               BUILDERR="$(abspath ${OPTARG})"
            fi
            ;;
         i)
            # Handle getops with invalid input
            if [[ ${OPTARG} == -* ]] ; then
               echo "Invalid input for option -${opt}"
               shift $((OPTIND-1))
               break
            else
               MELDIR="$(abspath ${OPTARG})"
            fi
            ;;
         :)
            echo "Option -${OPTARG} requires an argument." >&2
            ;;
         \?)
            echo "Invalid option: -${OPTARG}" >&2
            ;;
         h)
            usage
            exit 1
            ;;
      esac
   done
}


# Collect information from host 
#    Input: $1=Output directory name 
#           $2=Filename for host info collection
get_hostinfo () {
   local __output="${1}/host/${2}"
   
   echo -en "\nHost Distro Info:\n" >> ${__output}
   lsb_release -a >> ${__output} 2> /dev/null
   echo -en "\nHost System Info:\n" >> ${__output}
   uname -a >> ${__output}
   echo -en "\nHost env Info:\n" >> ${__output}
   printenv | sort >> ${__output}
   echo -en "\nHost disk space usage:\n" >> ${__output}
   df -h >> ${__output}
   echo -en "\nHost memory usage:\n" >> ${__output}
   free -ht >> ${__output}
   echo -en "\n" >> ${__output}
}


# Collect license info from host 
#    Input: $1=Output directory name 
#           $2=Filename for host info collection
#           $3=License info variable name
get_hostlicenseinfo () {
   local __outputdir="${1}"
   local __output="${1}/host/${2}"
   local __licensename="${3}"
   local __license=`printenv "${3}"`

   echo -en "\n${__licensename}:\n" >> ${__output}
   # Check if license variable is set in shell environment
   if [ -n "${__license}" ]; then
      echo -en "${__license}\n" >> ${__output}
      # Process license variable string
      for i in $(echo "${__license//:/$'\n'}"); do
         # Check if entry is a license file and exists
         if [ -f "${i}" ]; then
            # Make a copy of the license file
            cp ${i} ${__outputdir}/host/.
         # Check if entry is a license server
         elif [[ ${i} == *"@"* ]]; then
            echo -en "\n${i} is a license server\n" >> ${__output}
         # Entry is invalid
         else
            echo -en "\n${i} does not seem to be a valid entry\n" >> ${__output}
         fi
      done
   else
      echo -en "\n${__licensename} is not set!\n" >> ${__output}
   fi
}


# Collect prerequisite packages/libraries from host
#    Input: $1=Output directory name 
#           $2=Filename for host info collection
get_hostprereqsinfo () {
   local __outputdir="${1}"
   local __output="${1}/host/${2}"
   local __hostos_distid=`lsb_release -i -s`
   local __hostos_distvers=`lsb_release -r -s`
   local __pkgs
   
   echo -en "\nHost OS is ${__hostos_distid} ${__hostos_distvers}:\n" >> ${__output}
   case "${__hostos_distid}" in
      Ubuntu)
         __pkgs="bmap-tools bzip2 chrpath cvs diffstat gawk gcc git-core gzip g++ \
                 libgl1-mesa-dev libglu1-mesa-dev libncurses5-dev libsdl1.2-dev \
                 lsb-release make patch python python3 subversion tar texinfo \
                 texi2html ubuntu-minimal ubuntu-standard zip"
         dpkg-query -W -f='${binary:Package} ${Version} ${db:Status-Status}\n' ${__pkgs} >> ${__output}
         ;;      
      CentOS|RedHat*)
         __pkgs="bzip2 chrpath cvs diffstat gawk gcc gcc-c++ git glibc-devel \ 
                 glibc-static gzip make ncurses-devel patch perl-Thread-Queue \
                 python python34 python-virtualenv redhat-lsb SDL-devel sqlite \
                 subversion tar tetex texinfo texi2html wget"
         rpm -q ${__pkgs} >> ${__output}
         ;;
   esac
}


# Collect MEL installation info from host 
#    Input: $1=Output directory name 
#           $2=Filename for host info collection
get_melinstallinfo () {
   local __outputdir="${1}"
   local __output="${1}/host/${2}"
   
   if [ -d "${HOMEDIR}/.mentor" ]; then
      cp -a ${HOMEDIR}/.mentor/.registry ${__outputdir}/host/mentor-registry
   else
      echo -en "\nNo MEL install info found!\n" >> ${__output}
   fi
}


# Collect MEL project build and error logs 
#    Input: $1=Output directory name 
#           $2=BUILDERR
#           $3=BUILDDIR
get_melbuildinfo () {
   local __outputdir="${1}"
   local __builderr="${2}"
   local __builddir="${3}"
   
   local __arch="$(echo ${__builderr#/*/work/} | cut -d"/" -f1)"
   local __pkgname="$(echo ${__builderr#/*/work/} | cut -d"/" -f2)"
   local __pkgdir="${__builddir}/tmp/work/${__arch}/${__pkgname}"

   cp -a ${__builddir}/buildhistory/images/ ${__outputdir}/mel/.
   cp -a ${__builddir}/tmp/log/ ${__outputdir}/mel/.
   cp -a ${__builddir}/conf/ ${__outputdir}/mel/.

   mkdir ${__outputdir}/mel/${__arch}
   cp -a ${__pkgdir} ${__outputdir}/mel/${__arch}/.
}



#
# Start execution of script
#
#set -x

# Check 1st cmdline argument
if [[ ${1} == -* ]]; then
   # Process script input arguments 
   process_cmdline_args "${@}"
   if [ ! -f "${BUILDERR}" ] || [ ! -d "${MELDIR}" ]; then
      echo -en "\nERROR:  One or more input arguments were invalid!!!\n\n"
   fi
elif [ -z "${@}" ]; then
   echo -en "\nWARNING:  No input arguments were given on command line.\n\n"
fi

# Check for valid BUILDERR
while [ ! -f "${BUILDERR}" ]; do
   echo "Please enter error log filename and complete path displayed from MEL project (option -e):"
   read BUILDERR
   BUILDERR="$(abspath ${BUILDERR})"
   if [ ! -f "${BUILDERR}" ]; then
      echo -en "\nERROR (option -e):  Invalid error log filename and path!!!\n\n"
   fi
done

# Check for valid MELDIR
while [ ! -d "${MELDIR}" ]; do
   echo "Please enter MEL installation path (option -i):"
   read MELDIR
   MELDIR="$(abspath ${MELDIR})"
   if [ ! -d "${MELDIR}" ]; then
      echo -en "\nERROR (option -i):  Invalid MEL installation path!!!\n\n"
   fi
done

# Construct BUILDDIR from BUILDERR
if [ -z ${BUILDDIR} ]; then
   BUILDDIR="${BUILDERR%%/tmp/*}"
fi

# Clean up artifacts from previous run of the script
if [ -d "${OUTPUTDIRNAME}" ]; then
   rm -rf ${OUTPUTDIRNAME}
fi

if [ -a "${OUTPUTDIRNAME}.tar.bz2" ]; then
   rm ${OUTPUTDIRNAME}.tar.bz2
fi

# Create directories for saving script outputs
mkdir -p ${OUTPUTDIRNAME}/host ${OUTPUTDIRNAME}/mel

# Collect host information
get_hostinfo ${OUTPUTDIRNAME} ${HOSTINFOFILE}
get_hostlicenseinfo ${OUTPUTDIRNAME} ${HOSTINFOFILE} ${MGLS_LICENSE}
get_hostlicenseinfo ${OUTPUTDIRNAME} ${HOSTINFOFILE} ${LM_LICENSE}
get_hostprereqsinfo ${OUTPUTDIRNAME} ${HOSTINFOFILE}
get_melinstallinfo ${OUTPUTDIRNAME} ${HOSTINFOFILE}
get_melbuildinfo ${OUTPUTDIRNAME} ${BUILDERR} ${BUILDDIR}

# Create tarball with info collected in output directory
echo "Creating ${OUTPUTDIRNAME}.tar.bz2..."
tar cjpf ${OUTPUTDIRNAME}.tar.bz2 ${OUTPUTDIRNAME} 2>> ${OUTPUTDIRNAME}/host/${HOSTINFOFILE}

# Need to check exit status of tar and handle appropriately
if [[ ${?} -ne 0 ]]; then
   echo -en "\ntar errno: ${?}\n" >> ${OUTPUTDIRNAME}/host/${HOSTINFOFILE}
   cp ${OUTPUTDIRNAME}/host/${HOSTINFOFILE} .
   echo "An error occurred during tar."
   echo "Please attach ${HOSTINFOFILE} to your Support Request ticket."
   exit 1
else
   # Remove output directory after creating tarball archive file
   if [ -d "${OUTPUTDIRNAME}" ]; then
      rm -rf ${OUTPUTDIRNAME}
   fi
   echo "Done!!!"
   echo -en "\nPlease attach ${OUTPUTDIRNAME}.tar.bz2 to your Support Request ticket.\n\n"
fi
